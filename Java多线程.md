---
title: Java多线程
tags: Java,Thread,Runnable
---


**1.Thread中的start（）方法在执行完后立刻返回，只起一个引导的作用**
**2.Runnable和Callable不能一起用，因为再用线程池时会出现歧义**
**3.Runnable和Callable都是有run（）或call（）方法的静态程序，真正要将程序变成线程，需要Thread或线程池的介入，submit（）用来提交callable，excutor（）用来提交runnable**
**4.如果直接使用runnable的run（）方法，可以在main（）方法主线程中调用**
**5.在使用优先级线程策略时，java的10个优先级并不能很好的对应到windows的7个动态优先级，更不能对应到solaris的2^31个优先级数。如果要结合操作系统的话，实现跨平台，只能getPriority（）或setPriority（）到最高、最低、中间这三个优先级（这三者有专门的静态常量定义）**
**6.线程启动前设置守护线程setDaemon（），作为守护线程**
**7.Java的线程源自C的低级的pThread线程**
**8.主动让出线程（暂时挂起suspend），让指定目标线程执行join（）**
**9.中断线程interrupt（），判断中断isInterrupted（）**
**10.A线程用join（）陷入B线程，在B线程中可以中断A线程以关闭自身B线程**
**11.如果水平足够高，原子操作可以代替锁机制，但几乎不可能**
**12.volatile关键字确保了多线程共享资源的可视性，尤其是在多个物理核心上的多线程，物理核心有可能会有自己的缓存，资源的临时改变保存在缓存中，因此其他线程可能来不及看到这种改变，而volatile则确保改变马上被写入内存，从而使资源立刻被看到**
**13.Java的递增操作涉及一个读操作和一个写操作，读取原数值，加，将运算后数值写回内存**
**14.当然Java针对long，double给出了原子性的long或double类，专门用来处理long的原子性操作，long++等**
**15.同步关键字synchronized不属于方法签名的组成部分，可以用来覆盖接口、抽象类方法**
**16.如果不需要更改共享资源，那么只需要使用ThreadLocal类来完成资源共享，这个类会为每一个线程创建一个目标资源的副本给线程，而线程在生命周期内的操作都是在这个副本上，对原资源没有影响，可以说是假的共享资源**
**17.ReadWriteLock专用于多个读者和一个写者的情况：读操作没有锁，写操作仅一个锁**

