---
title: 快速排序 
tags: 算法,排序
---

快速排序隶属于交换类排序，几乎是目前最快的排序算法，因此称为快速排序。其采用了一种分治的思想：总是将原问题分解为较小的子问题，然后采用归并思想，将小问题的解合并成原问题的解。其具体是随便找一个目标值，利用其将比其小的和大的分散两边，然后再分别对小的一边和大的一边进行上述同样的操作，直到分解到一个的时候。

#### 具体实现（Java）
```javascript?linenums
import java.util.Scanner;
public class QuickSort {
	
	private static final int Length = 11;

	public static void main(String[] args) {		
		int[] array = new int[Length];
		Scanner scanner = new Scanner(System.in);
		for(int i=1;i<Length;i++){
			if(scanner.hasNextInt()) array[i] = scanner.nextInt();
		}
		scanner.close();
		array[0] = 0;
		int Low = 1;
		int High = Length-1;
		new QuickSort().quickSort(array,Low,High);
		for(int i=1;i<Length;i++) System.out.print(array[i]+" ");
	}
	
	/*
	 * 快速排序在交换值的时候，并不是真的交换low与high的值，而是将其中一个根据规则放到他该去的地方
	 * 这时，原本low或high就都变成了复制的值，有两个相同值，但是其中待交换位指针是没有变的，也就是说
	 * 被复制的值所在的位置会在之后被之后的操作替换掉，从而消除两个相同值。
	 */
	
	public void quickSort(int[] array,int Low,int High){
		int L = Low,R = High;
		int temp;
		if(Low < High){
			array[0] = array[L];
			while(L < R){
				while(L < R && array[R] >= array[0]) R--;
				array[L] = array[R];
				while(L < R && array[L] <= array[0]) L++;
				array[R] = array[L];
			}
			array[L] = array[0];
			temp = L;
			quickSort(array, Low, temp-1);           //注意这里之所以是temp-1的原因是:减少计算量,因为temp指向驱动轴,
			quickSort(array, temp+1, High);          //当然再计算一遍也没有关系，但是为了减少计算量,因为这是算法
		}
	}

}

```
